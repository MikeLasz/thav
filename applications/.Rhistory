color="Rank3", shape="Rank3")
#' Compute the thAV estimator
#'
#' @param data Data matrix of size $n\times d$
#' @param seq_r Sequence of considered regularization parameters
#' @param C constant C that is used to calibrate the AV regularization parameter
#' @param lambda Threshold factor lambda: We threshold the AV solution by lambda*C*av$TuningParameter
#' @return The thresholded AV estimator
#' @export
thAV.estimator <- function( data, seq_r=0.2 * 0.95^(40:0), C=0.3, lambda=3, mute=FALSE)
{
av <- av_glasso(data, seq_r, C)
if(!mute)
{
print(paste0("Selected Regularization Parameter: ", av$TuningParameter))
}
return( threshold(av, C, lambda))
}
# our method:
thav <- thAV.estimator(huge.npn(se.mb.amgut2$est$data), lambda=1, C=0.5, seq_r=seq(0.05, 0.4, length.out = 40))
#' Exemplary recovery in F_1-score of the top edges for several settings
#'
#' @param n_seq Sequence of sample sizes used for the simulation
#' @param d_seq Sequence of dimensionaly of the precision matrix used for the simulation
#' @param num_top Amount of entries that are going to be analyzed
#' @param graph Type of the graph
#' @param latex If TRUE, returns a latex output
#' @return Table including the largest, the num_top'th largest absolute value of Theta, the reference value 6Cr, and the proportional amount of recovered top edges for several settings
#' @export
thav_topvalues <- function(n_seq, d_seq, num_top=50, graph="random", latex=TRUE)
{
summary <- matrix( rep(0, 4 * length(n_seq)), ncol=length(n_seq))
rownames(summary) <- c("top1", paste0("top",num_top), "6Cr", "occurence%")
for(num_setting in 1:length(n_seq))
{
d <- d_seq[num_setting]
n <- n_seq[num_setting]
theta <- generateGraph(d, graph=graph)[[1]]
data <- mvrnorm(n, mu=rep(0, d), Sigma=solve(theta))
#av <- av_glasso(data) # old version
av <- av_glasso(data, seq_r=seq(0.05, 0.4, length.out = 40), C=0.5)
av_tp <- av$TuningParameter
#thav <- threshold(av) # old version
thav <- threshold(av, C=0.5, lambda=1)
top_values <- sort( abs(theta[ upper.tri(theta)]), decreasing=TRUE)
top_1 <- top_values[1]
top_num_top <- top_values[num_top]
top_coords <- matrix(rep(0, 2*50), ncol=2)
counter_thav <- 0
for(j in 1:50)
{
top_coords[j, ] <- which( matrix(abs(theta), ncol=d)==top_values[j], arr.ind=TRUE)[1, ]
if( thav[ top_coords[j, 1], top_coords[j, 2]] != 0)
{
counter_thav <- counter_thav + 1
}
}
summary[, num_setting] <- c(top_values[1], top_values[num_top], 6 * 0.3 * av_tp, counter_thav / num_top)
}
stargazer( round(summary, 2))
}
knitr::opts_chunk$set(echo = TRUE)
thav_topvalues(n_seq=c(300, 200, 400), d_seq=c(200, 300, 200))
library("matrixcalc")
thav_topvalues(n_seq=c(300, 200, 400), d_seq=c(200, 300, 200))
library("MASS")
thav_topvalues(n_seq=c(300, 200, 400), d_seq=c(200, 300, 200))
library("stargazer")
thav_topvalues(n_seq=c(300, 200, 400), d_seq=c(200, 300, 200))
thav_topvalues(n_seq=c(300, 200, 400), d_seq=c(200, 300, 200), graph="scale-free")
theta <- generateGraph(40)[[1]]
data <- mvrnorm(200, mu=rep(0, 40), Sigma=solve(theta))
var(scale(data))
View(var(scale(data)))
#' Compare the similarity of thAV estimates based on different C.
#'
#' @param n Number of samples
#' @param d Number of dimensions
#' @param seq_C Sequence of different C used to be compared
#' @param graph Graph type
#' @param num_reps Number of repetitions of the recovery task for each recovery method
#' @param latex If TRUE, this function returns a latex output via the stargazer package
#' @return Matrix with average (and standard deviation) of F_1-score between thAV estimates corresponding to the values in seq_C. In addition, this method also prints the average F_1-score between a thAV (based on a specific C) and the true graph.
#' @export
comparison_similarity <- function(n, d, seq_C=c(0.2, 0.3, 0.4, 0.5), graph="random", num_reps=50, latex=FALSE)
{
pb <- txtProgressBar(min = 0, max = length(seq_C) * (length(seq_C) - 1) / 2, style = 3)
dif_f1 <- matrix(rep(0, length(seq_C)^2 + length(seq_C)), ncol=length(seq_C))
colnames(dif_f1) <- seq_C
rownames(dif_f1) <- c(seq_C, "f1")
seq_r <- seq(0.03, 1.5, length.out = 80)
for(i in 1:(length(seq_C) - 1))
{
for(j in (i + 1):length(seq_C))
{
dif_f1_over_reps <- rep(0, num_reps)
for(rep in 1:num_reps)
{
theta <- generateGraph(d, graph=graph)[[1]]
#theta <- graph[[1]]
data <- mvrnorm(n, mu=rep(0, d), Sigma=solve(theta))
data <- scale(data) # new
#thav1 <- thAV.estimator(data, C=seq_C[i], seq_r=seq_r)
#thav2 <- thAV.estimator(data, C=seq_C[j], seq_r=seq_r)
##### new:
thav1 <- thAV.estimator(data, seq_r=seq(0.05, 0.4, length.out = 40), C=C[i], lambda=1)
thav2 <- thAV.estimator(data, seq_r=seq(0.05, 0.4, length.out = 40), C=C[j], lambda=1)
score <- f1score(thav1, thav2)$f1
if(is.nan(score))
{
dif_f1_over_reps[rep] <- 0
}
else
{
dif_f1_over_reps[rep] <- f1score(thav1, thav2)$f1
}
}
setTxtProgressBar(pb, i + j)
dif_f1[i, j] <- dif_f1[j, i] <- paste0(round(mean(dif_f1_over_reps), 2), " (", round(std(dif_f1_over_reps), 2), ")")
}
}
remove(thav1)
remove(thav2)
close(pb)
#calculation of f1 scores between estimation and true graph
pb <- txtProgressBar(min = 0, max = num_reps, style = 3)
diag( dif_f1) <- rep(1, length(seq_C))
for(i in 1:length(seq_C))
{
general_f1 <- rep(0, num_reps)
for(rep in 1:num_reps)
{
theta <- generateGraph(d, graph=graph)[[1]]
data <- mvrnorm( n, mu=rep(0, d), Sigma=solve(theta))
data <- scale(date) # new
#thav <- thAV.estimator(data, C=seq_C[i])
thav <- thAV.estimator(data, C=seq_C[i], seq_r=seq(0.05, 0.4, length.out = 40), lambda=1)
general_f1[rep] <- f1score(theta, thav)$f1
setTxtProgressBar(pb, rep)
}
dif_f1[length(seq_C) + 1, i] <- paste0(round(mean(general_f1), 2), "(", round(std(general_f1), 2), ")")
}
remove(thav)
close(pb)
if( latex)
{
stargazer( dif_f1)
}
else
{
return( dif_f1)
}
}
View(comparison_similarity)
View(comparison_similarity)
comparison_similarity( 300, 200, latex=TRUE, seq_C=c(0.3, 0.4, 0.5, 0.6, 0.7), num_resp=5)
comparison_similarity( 300, 200, latex=TRUE, seq_C=c(0.3, 0.4, 0.5, 0.6, 0.7), num_reps=5)
#' Compare the similarity of thAV estimates based on different C.
#'
#' @param n Number of samples
#' @param d Number of dimensions
#' @param seq_C Sequence of different C used to be compared
#' @param graph Graph type
#' @param num_reps Number of repetitions of the recovery task for each recovery method
#' @param latex If TRUE, this function returns a latex output via the stargazer package
#' @return Matrix with average (and standard deviation) of F_1-score between thAV estimates corresponding to the values in seq_C. In addition, this method also prints the average F_1-score between a thAV (based on a specific C) and the true graph.
#' @export
comparison_similarity <- function(n, d, seq_C=c(0.2, 0.3, 0.4, 0.5), graph="random", num_reps=50, latex=FALSE)
{
pb <- txtProgressBar(min = 0, max = length(seq_C) * (length(seq_C) - 1) / 2, style = 3)
dif_f1 <- matrix(rep(0, length(seq_C)^2 + length(seq_C)), ncol=length(seq_C))
colnames(dif_f1) <- seq_C
rownames(dif_f1) <- c(seq_C, "f1")
seq_r <- seq(0.03, 1.5, length.out = 80)
for(i in 1:(length(seq_C) - 1))
{
for(j in (i + 1):length(seq_C))
{
dif_f1_over_reps <- rep(0, num_reps)
for(rep in 1:num_reps)
{
theta <- generateGraph(d, graph=graph)[[1]]
#theta <- graph[[1]]
data <- mvrnorm(n, mu=rep(0, d), Sigma=solve(theta))
data <- scale(data) # new
#thav1 <- thAV.estimator(data, C=seq_C[i], seq_r=seq_r)
#thav2 <- thAV.estimator(data, C=seq_C[j], seq_r=seq_r)
##### new:
thav1 <- thAV.estimator(data, seq_r=seq(0.05, 0.4, length.out = 40), C=C[i], lambda=1)
thav2 <- thAV.estimator(data, seq_r=seq(0.05, 0.4, length.out = 40), C=C[j], lambda=1)
score <- f1score(thav1, thav2)$f1
if(is.nan(score))
{
dif_f1_over_reps[rep] <- 0
}
else
{
dif_f1_over_reps[rep] <- f1score(thav1, thav2)$f1
}
}
setTxtProgressBar(pb, i + j)
dif_f1[i, j] <- dif_f1[j, i] <- paste0(round(mean(dif_f1_over_reps), 2), " (", round(std(dif_f1_over_reps), 2), ")")
}
}
remove(thav1)
remove(thav2)
close(pb)
#calculation of f1 scores between estimation and true graph
pb <- txtProgressBar(min = 0, max = num_reps, style = 3)
diag( dif_f1) <- rep(1, length(seq_C))
for(i in 1:length(seq_C))
{
general_f1 <- rep(0, num_reps)
for(rep in 1:num_reps)
{
theta <- generateGraph(d, graph=graph)[[1]]
data <- mvrnorm( n, mu=rep(0, d), Sigma=solve(theta))
data <- scale(date) # new
#thav <- thAV.estimator(data, C=seq_C[i])
thav <- thAV.estimator(data, C=seq_C[i], seq_r=seq(0.05, 0.4, length.out = 40), lambda=1)
general_f1[rep] <- f1score(theta, thav)$f1
setTxtProgressBar(pb, rep)
}
dif_f1[length(seq_C) + 1, i] <- paste0(round(mean(general_f1), 2), "(", round(std(general_f1), 2), ")")
}
remove(thav)
close(pb)
if( latex)
{
stargazer( dif_f1)
}
else
{
return( dif_f1)
}
}
comparison_similarity( 300, 200, latex=TRUE, seq_C=c(0.3, 0.4, 0.5, 0.6, 0.7), num_reps=5)
#' Compare the similarity of thAV estimates based on different C.
#'
#' @param n Number of samples
#' @param d Number of dimensions
#' @param seq_C Sequence of different C used to be compared
#' @param graph Graph type
#' @param num_reps Number of repetitions of the recovery task for each recovery method
#' @param latex If TRUE, this function returns a latex output via the stargazer package
#' @return Matrix with average (and standard deviation) of F_1-score between thAV estimates corresponding to the values in seq_C. In addition, this method also prints the average F_1-score between a thAV (based on a specific C) and the true graph.
#' @export
comparison_similarity <- function(n, d, seq_C=c(0.2, 0.3, 0.4, 0.5), graph="random", num_reps=50, latex=FALSE)
{
pb <- txtProgressBar(min = 0, max = length(seq_C) * (length(seq_C) - 1) / 2, style = 3)
dif_f1 <- matrix(rep(0, length(seq_C)^2 + length(seq_C)), ncol=length(seq_C))
colnames(dif_f1) <- seq_C
rownames(dif_f1) <- c(seq_C, "f1")
seq_r <- seq(0.03, 1.5, length.out = 80)
for(i in 1:(length(seq_C) - 1))
{
for(j in (i + 1):length(seq_C))
{
dif_f1_over_reps <- rep(0, num_reps)
for(rep in 1:num_reps)
{
theta <- generateGraph(d, graph=graph)[[1]]
#theta <- graph[[1]]
data <- mvrnorm(n, mu=rep(0, d), Sigma=solve(theta))
data <- scale(data) # new
#thav1 <- thAV.estimator(data, C=seq_C[i], seq_r=seq_r)
#thav2 <- thAV.estimator(data, C=seq_C[j], seq_r=seq_r)
##### new:
thav1 <- thAV.estimator(data, seq_r=seq(0.05, 0.4, length.out = 40), C=seq_C[i], lambda=1)
thav2 <- thAV.estimator(data, seq_r=seq(0.05, 0.4, length.out = 40), C=seq_C[j], lambda=1)
score <- f1score(thav1, thav2)$f1
if(is.nan(score))
{
dif_f1_over_reps[rep] <- 0
}
else
{
dif_f1_over_reps[rep] <- f1score(thav1, thav2)$f1
}
}
setTxtProgressBar(pb, i + j)
dif_f1[i, j] <- dif_f1[j, i] <- paste0(round(mean(dif_f1_over_reps), 2), " (", round(std(dif_f1_over_reps), 2), ")")
}
}
remove(thav1)
remove(thav2)
close(pb)
#calculation of f1 scores between estimation and true graph
pb <- txtProgressBar(min = 0, max = num_reps, style = 3)
diag( dif_f1) <- rep(1, length(seq_C))
for(i in 1:length(seq_C))
{
general_f1 <- rep(0, num_reps)
for(rep in 1:num_reps)
{
theta <- generateGraph(d, graph=graph)[[1]]
data <- mvrnorm( n, mu=rep(0, d), Sigma=solve(theta))
data <- scale(date) # new
#thav <- thAV.estimator(data, C=seq_C[i])
thav <- thAV.estimator(data, C=seq_C[i], seq_r=seq(0.05, 0.4, length.out = 40), lambda=1)
general_f1[rep] <- f1score(theta, thav)$f1
setTxtProgressBar(pb, rep)
}
dif_f1[length(seq_C) + 1, i] <- paste0(round(mean(general_f1), 2), "(", round(std(general_f1), 2), ")")
}
remove(thav)
close(pb)
if( latex)
{
stargazer( dif_f1)
}
else
{
return( dif_f1)
}
}
comparison_similarity( 300, 200, latex=TRUE, seq_C=c(0.3, 0.4, 0.5, 0.6, 0.7), num_reps=5)
#' Compare the similarity of thAV estimates based on different C.
#'
#' @param n Number of samples
#' @param d Number of dimensions
#' @param seq_C Sequence of different C used to be compared
#' @param graph Graph type
#' @param num_reps Number of repetitions of the recovery task for each recovery method
#' @param latex If TRUE, this function returns a latex output via the stargazer package
#' @return Matrix with average (and standard deviation) of F_1-score between thAV estimates corresponding to the values in seq_C. In addition, this method also prints the average F_1-score between a thAV (based on a specific C) and the true graph.
#' @export
comparison_similarity <- function(n, d, seq_C=c(0.2, 0.3, 0.4, 0.5), graph="random", num_reps=50, latex=FALSE)
{
pb <- txtProgressBar(min = 0, max = length(seq_C) * (length(seq_C) - 1) / 2, style = 3)
dif_f1 <- matrix(rep(0, length(seq_C)^2 + length(seq_C)), ncol=length(seq_C))
colnames(dif_f1) <- seq_C
rownames(dif_f1) <- c(seq_C, "f1")
seq_r <- seq(0.03, 1.5, length.out = 80)
for(i in 1:(length(seq_C) - 1))
{
for(j in (i + 1):length(seq_C))
{
dif_f1_over_reps <- rep(0, num_reps)
for(rep in 1:num_reps)
{
theta <- generateGraph(d, graph=graph)[[1]]
#theta <- graph[[1]]
data <- mvrnorm(n, mu=rep(0, d), Sigma=solve(theta))
data <- scale(data) # new
#thav1 <- thAV.estimator(data, C=seq_C[i], seq_r=seq_r)
#thav2 <- thAV.estimator(data, C=seq_C[j], seq_r=seq_r)
##### new:
thav1 <- thAV.estimator(data, seq_r=seq(0.05, 0.4, length.out = 40), C=seq_C[i], lambda=1)
thav2 <- thAV.estimator(data, seq_r=seq(0.05, 0.4, length.out = 40), C=seq_C[j], lambda=1)
score <- f1score(thav1, thav2)$f1
if(is.nan(score))
{
dif_f1_over_reps[rep] <- 0
}
else
{
dif_f1_over_reps[rep] <- f1score(thav1, thav2)$f1
}
}
setTxtProgressBar(pb, i + j)
dif_f1[i, j] <- dif_f1[j, i] <- paste0(round(mean(dif_f1_over_reps), 2), " (", round(std(dif_f1_over_reps), 2), ")")
}
}
remove(thav1)
remove(thav2)
close(pb)
#calculation of f1 scores between estimation and true graph
pb <- txtProgressBar(min = 0, max = num_reps, style = 3)
diag( dif_f1) <- rep(1, length(seq_C))
for(i in 1:length(seq_C))
{
general_f1 <- rep(0, num_reps)
for(rep in 1:num_reps)
{
theta <- generateGraph(d, graph=graph)[[1]]
data <- mvrnorm( n, mu=rep(0, d), Sigma=solve(theta))
data <- scale(data) # new
#thav <- thAV.estimator(data, C=seq_C[i])
thav <- thAV.estimator(data, C=seq_C[i], seq_r=seq(0.05, 0.4, length.out = 40), lambda=1)
general_f1[rep] <- f1score(theta, thav)$f1
setTxtProgressBar(pb, rep)
}
dif_f1[length(seq_C) + 1, i] <- paste0(round(mean(general_f1), 2), "(", round(std(general_f1), 2), ")")
}
remove(thav)
close(pb)
if( latex)
{
stargazer( dif_f1)
}
else
{
return( dif_f1)
}
}
comparison_similarity( 300, 200, latex=TRUE, seq_C=c(0.3, 0.4, 0.5, 0.6, 0.7), num_reps=2)
different_C <- function(n, d, seq_C=seq(0.3, 3.5, length.out = 10))
{
theta <- simulateGraph(d, 0.07)$PCor
#theta <- generateGraph(d)[[1]]
data <- mvrnorm(n=n, mu=rep(0, d), Sigma=solve(theta))
f1_range <- prec_range <- recall_range <- rep(0, length(seq_C))
for(j in 1:length(seq_C))
{
print(j)
thav <- thAV.estimator(data, C=seq_C[j])
score <- f1score(theta, thav)
f1_range[j] <- score$f1
prec_range[j] <- score$precision
recall_range[j] <- score$recall
}
plot(x=seq_C, y=f1_range, col="red", ylim=c(0, 1), main=paste0("n=", n, ", d=", d))
lines(x=seq_C, y=prec_range, col="blue")
lines(x=seq_C, y=recall_range, col="green")
legend(x="bottomright", legend=c("f1", "precision", "recall"), col=c("red", "blue", "green"), lty=1)
}
lossvsC <- function(n, d, C)
{
#theta <- simulateGraph(d, 0.07)$PCor
theta <- generateGraph(d)[[1]]
data <- mvrnorm(n=n, mu=rep(0, d), Sigma=solve(theta))
data <- scale(data)
rho <- seq(0.05, 0.4, length.out = 40) #0.2 * 0.95^(40:0)
losses <- matrix(rep(0, 2*40), ncol=2)
colnames(losses) <- c("tuning parameter", "inf-loss")
path <- glassopath(var(data), rholist=rho)$wi
for (j in 1:40)
{
losses[j, 1] <- rho[j]
losses[j, 2] <- infloss(theta, path[,,j])
}
plot(x=losses[,1], y=C*losses[, 1], ylim=c(0, 0.4), col="red", xlab="Tuning Parameter", ylab="Inf-loss")
lines(losses, col="blue")
legend(x="top", legend=c("C*lambda", "inf-loss"), col=c("red", "blue"), lty=1)
}
lossvsC(300, 200, 0.5)
lossvsC <- function(n, d, C, loss=infloss)
{
#theta <- simulateGraph(d, 0.07)$PCor
theta <- generateGraph(d)[[1]]
data <- mvrnorm(n=n, mu=rep(0, d), Sigma=solve(theta))
data <- scale(data)
rho <- seq(0.05, 0.4, length.out = 40) #0.2 * 0.95^(40:0)
losses <- matrix(rep(0, 2*40), ncol=2)
colnames(losses) <- c("tuning parameter", "inf-loss")
path <- glassopath(var(data), rholist=rho)$wi
for (j in 1:40)
{
losses[j, 1] <- rho[j]
losses[j, 2] <- loss(theta, path[,,j])
}
plot(x=losses[,1], y=C*losses[, 1], ylim=c(0, 0.4), col="red", xlab="Tuning Parameter", ylab="Inf-loss")
lines(losses, col="blue")
legend(x="top", legend=c("C*lambda", "inf-loss"), col=c("red", "blue"), lty=1)
}
lossvsC(300, 200, 0.5)
quantile_loss <- function(theta, est, top)
{
dif <- theta- est
diag(dif) <- rep(0, dim(theta)[1])
differences <- dif[dif[upper.tri(dif)]!=0]
differences <- sort(abs(differences),decreasing = TRUE)
return(differences[top])
#return(differences[as.integer(perc*length(differences))])
}
quantile_loss <- function(theta, est, top=50)
{
dif <- theta- est
diag(dif) <- rep(0, dim(theta)[1])
differences <- dif[dif[upper.tri(dif)]!=0]
differences <- sort(abs(differences),decreasing = TRUE)
return(differences[top])
#return(differences[as.integer(perc*length(differences))])
}
lossvsC(300, 200, 0.5, loss=quantile_loss)
quantile_loss <- function(theta, est, top=5)
{
dif <- theta- est
diag(dif) <- rep(0, dim(theta)[1])
differences <- dif[dif[upper.tri(dif)]!=0]
differences <- sort(abs(differences),decreasing = TRUE)
return(differences[top])
#return(differences[as.integer(perc*length(differences))])
}
lossvsC(300, 200, 0.5, loss=quantile_loss)
quantile_loss <- function(theta, est, top=10)
{
dif <- theta- est
diag(dif) <- rep(0, dim(theta)[1])
differences <- dif[dif[upper.tri(dif)]!=0]
differences <- sort(abs(differences),decreasing = TRUE)
return(differences[top])
#return(differences[as.integer(perc*length(differences))])
}
lossvsC(300, 200, 0.5, loss=quantile_loss)
lossvsC(200, 300, 0.5, loss=quantile_loss)
lossvsC(400, 200, 0.5, loss=quantile_loss)
quantile_loss <- function(theta, est, top=15)
{
dif <- theta- est
diag(dif) <- rep(0, dim(theta)[1])
differences <- dif[dif[upper.tri(dif)]!=0]
differences <- sort(abs(differences),decreasing = TRUE)
return(differences[top])
#return(differences[as.integer(perc*length(differences))])
}
lossvsC(300, 200, 0.5, loss=quantile_loss)
lossvsC(200, 300, 0.5, loss=quantile_loss)
lossvsC(400, 200, 0.5, loss=quantile_loss)
performance_thav(800, num_reps = 2, seq_r=seq(0.05, 0.4, length.out = 40), C=0.5, lambda=1)
performance_thav(800, num_reps = 2, graph="scale-free", seq_r=seq(0.05, 0.4, length.out = 40), C=0.5, lambda=1)
